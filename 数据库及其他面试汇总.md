# 数据库及其他面试汇总

[TOC]



## 计算机基础

### 编程范式

| 面向对象编程（OOP） | 面向过程编程（PP) | 多范式编程语言 |
| ------------------- | ----------------- | -------------- |
| Java                | C语言             | C#             |
| C++                 | Fortran           | Javascript     |
| Python              |                   | Swift          |



### C++, java, iOS程序在内存的分布

| C++                                                      | Java                                                         | iOS                                                          |
| -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 代码区<br>存放程序的可执行代码，是只读的                 | 方法区<br>存放类的信息、静态变量、常量、即时编译后的代码等   | 代码段<br>存放应用程序的可执行代码，是只读的                 |
| 数据区<br>包括初始化的全局变量和静态变量                 | 本地方法栈<br>类似于虚拟机栈，但是用于执行本地（非Java）方法 | 数据段<br>包括初始化的全局变量和静态变量，以及常量           |
| 堆区<br>动态内存区域，用于存放程序运行时动态分配的内存   | 堆区<br>存放对象实例。堆是所有线程共享的内存区域，它是垃圾回收的主要区域 | 堆区<br>动态内存区域，用于存放程序运行时动态分配的内存       |
| 栈区<br>存放函数的参数值、局部变量和函数调用时的返回地址 | 虚拟机栈<br>每个线程都有一个私有的栈，用于存储Java方法的局部变量、操作数栈、动态链接、方法出口等信息。 | 栈区<br>存放函数调用时的局部变量、函数参数和返回地址。       |
| 全局/静态区<br>存放未初始化的全局变量和静态变量          | 程序计数器<br>记录当前线程执行的字节码行号，每个线程都有一个独立的程序计数器 | 内存映射区<br>存放动态链接库、共享库等，以及一些映射到文件的内存区域 |
|                                                          |                                                              | 文件映射区<br>存放通过`mmap`等方式映射到文件的内存。         |
|                                                          |                                                              | 栈随机化区<br>用于防止栈溢出攻击，增加程序的安全性           |



### 函数式编程概念

函数式编程（Functional Programming，简称FP）是一种编程范式，它将计算视为数学函数的评估，强调将计算过程分解为函数的组合和应用。函数式编程的核心思想包括以下关键概念：

1. **纯函数（Pure Function）：** 纯函数是指具有以下特性的函数：
    - 对于相同的输入，始终产生相同的输出。
    - 在执行过程中不会修改外部状态（没有副作用）。
    - 仅依赖于其输入参数，不依赖于全局变量或可变状态。

2. **不可变性（Immutability）：** 不可变性指的是数据一旦创建就不能被修改。在函数式编程中，数据被视为不可变的，任何对数据的修改都会创建新的数据，而不是在原始数据上进行修改。

3. **函数作为一等公民（First-Class Functions）：** 在函数式编程中，函数被视为一等公民，可以像其他数据类型一样进行传递、分配给变量、作为参数传递给其他函数，以及作为函数的返回值。

4. **高阶函数（Higher-Order Functions）：** 高阶函数是可以接受一个或多个函数作为参数，并且/或返回一个函数的函数。它们支持函数的组合和抽象。

5. **函数组合（Function Composition）：** 函数组合是将多个函数组合成一个新的函数的过程，通过这种方式可以创建复杂的计算过程。

6. **递归（Recursion）：** 递归是函数式编程中常用的迭代方式，它通过函数自身的调用来解决问题，而不是使用显式的循环结构。

7. **惰性计算（Lazy Evaluation）：** 惰性计算是一种延迟执行的策略，只有在需要时才进行计算。这有助于节省计算资源。

函数式编程的主要目标是提高代码的可维护性、可测试性和可复用性，减少副作用和错误。

eg. Swift支持多种高阶函数，其中一些常用的包括`map`、`filter`、`reduce`和`flatMap`等。以下是一个使用`map`高阶函数的示例，该示例将数组中的每个元素都加倍：

```swift
let numbers = [1, 2, 3, 4, 5]

// 使用 map 高阶函数将数组中的每个元素都加倍
let doubledNumbers = numbers.map { $0 * 2 }

print(doubledNumbers) // 输出 [2, 4, 6, 8, 10]
```

在上面的示例中，我们有一个包含整数的数组`numbers`，然后使用`map`高阶函数将数组中的每个元素都加倍。`map`函数接受一个闭包作为参数，该闭包定义了对数组元素的转换操作。在这个闭包中，`$0`表示数组中的当前元素，我们将它乘以2，然后`map`函数返回一个新的数组`doubledNumbers`，其中包含了加倍后的元素。

这个示例演示了如何使用高阶函数来执行简单的数据转换操作，而不需要显式的循环。高阶函数可以提高代码的可读性和可维护性，并降低出错的机会。



### 设计模式（创建型模式）

设计模式通常分为三大类：创建型模式、结构型模式和行为型模式。每一类都解决了特定的问题或场景。以下是这些类别下的一些常见设计模式：

1.   **创建型模式（Creational Patterns）**

这些模式与对象创建机制有关，帮助创建对象，同时隐藏创建逻辑，而不是使用新运算符直接实例化对象。这增强了程序的灵活性，以决定要创建哪个对象。

- **单例模式（Singleton）**: 确保类只有一个实例，并提供全局访问点。
- **工厂方法模式（Factory Method）**: 定义一个用于创建对象的接口，但让子类决定实例化哪个类。
- **抽象工厂模式（Abstract Factory）**: 创建相关或依赖对象的家族，而不明确指定具体类。
- **建造者模式（Builder）**: 分步骤构建复杂对象，允许用户仅使用特定的步骤。
- **原型模式（Prototype）**: 通过复制现有的实例来创建新的实例。

2.   **结构型模式（Structural Patterns）**

这些模式与对象的组合有关，通常用于形成大的对象结构。这类模式关注类和对象的组合。

- **适配器模式（Adapter）**: 允许不兼容的接口一起工作。
- **桥接模式（Bridge）**: 分离抽象部分和实现部分，使它们可以独立变化。
- **组合模式（Composite）**: 将对象组合成树形结构以表示部分-整体层次结构。
- **装饰器模式（Decorator）**: 动态地给一个对象添加一些额外的职责。

3.   **行为型模式（Behavioral Patterns）**

这些模式特别关注对象之间的通信。

- **中介者模式（Mediator）**: 定义一个封装一组对象如何交互的对象。

- **观察者模式（Observer）**: 对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖者都会得到通知并自动更新。

- **状态模式（State）**: 允许一个对象在其内部状态改变时改变它的行为。

- **策略模式（Strategy）**: 定义一系列算法，把它们一个个封装起来，并使它们可相互替换。

    ​    

### 单例模式

单例模式是一种创建型设计模式，其目的是确保一个类只有一个实例，并提供一个全局访问点让程序可以访问该实例。这意味着当你希望在整个应用程序中共享某个对象时，可以使用单例模式。

单例模式通常包含以下要素：

1. **私有构造函数（Private Constructor）：** 单例类通常会有一个私有的构造函数，防止外部直接实例化该类。

2. **私有静态实例（Private Static Instance）：** 单例类会包含一个私有的静态实例，用于保存该类的唯一实例。

3. **公有静态方法（Public Static Method）：** 单例类提供一个公有的静态方法，允许其他类访问该类的唯一实例。这个方法通常称为`sharedInstance`、`getInstance`等。

下面是一个简单的Swift示例，展示了如何实现单例模式：

```swift
class Singleton {
    // 私有静态实例
    private static let sharedInstance = Singleton()

    // 私有构造函数
    private init() {
        // 初始化代码
    }

    // 公有静态方法，用于获取唯一实例
    static func shared() -> Singleton {
        return sharedInstance
    }

    // 其他功能方法
    func someFunction() {
        // 实现某些功能
    }
}

// 使用单例
let singletonInstance = Singleton.shared()
singletonInstance.someFunction()
```

在这个示例中，`Singleton`类的唯一实例被定义为一个私有的静态常量`sharedInstance`。通过提供公有的静态方法`shared()`，其他部分的代码可以获取这个唯一实例。这确保了在应用程序中只能有一个`Singleton`实例存在。



### 开发代码设计原则

软件开发过程中，有一些常用的设计原则和准则，它们有助于编写可维护、可扩展和可重用的代码。以下是一些常见的软件开发代码设计原则：

1. **单一职责原则 (Single Responsibility Principle - SRP):**
    - 一个类应该只有一个引起变化的原因。换句话说，一个类应该只有一个职责。

2. **开放封闭原则 (Open/Closed Principle - OCP):**
    - 软件实体（类、模块、函数等等）应该对扩展开放，对修改关闭。这意味着通过添加新功能来扩展系统，而不是修改现有的代码。

3. **里氏替换原则 (Liskov Substitution Principle - LSP):**
    - 子类型必须能够替代其基类型，而不导致程序的正确性受到破坏。

4. **依赖倒置原则 (Dependency Inversion Principle - DIP):**
    - 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

5. **接口隔离原则 (Interface Segregation Principle - ISP):**
    - 不应该强迫一个类去实现它用不到的接口。一个类应该只和它需要的接口发生关系。

6. **合成/聚合复用原则 (Composition/Aggregation Reuse Principle - CARP):**
    - 首选使用对象的合成/聚合，而不是继承来达到复用的目的。通过将对象组合到新的对象中，可以更灵活地达到复用的目的。

7. **迪米特法则 (Law of Demeter - LoD):**
    - 一个对象应该对其他对象有最少的了解。即一个对象不应直接调用另一个对象的内部方法，而应通过中介者或者代理等方式。

8. **最小知识原则 (Principle of Least Knowledge - Law of Demeter):**
    - 一个模块不应该知道太多其他模块的细节。模块之间的通信应该是简单直接的。

9. **反腐蚀层 (Anticorruption Layer):**
    - 在不同的系统之间建立一个抽象的层，以防止两个系统之间的耦合。



## 数据库相关

### 数据库事务概念

数据库事务（Database Transaction）是指作为单个逻辑工作单元执行的一系列数据库操作。事务是数据库管理系统（DBMS）中的重要概念，它确保数据库的一致性、完整性和可靠性。



### 事务特点（ACID）

**原子性（Atomicity）：** 事务是一个原子操作，它要么完全执行，要么完全不执行。如果事务中的任何一部分操作失败，整个事务将被回滚（撤销），并且数据库状态不会受到影响。原子性确保了数据库的一致性。

**一致性（Consistency）：** 事务在执行前后，数据库必须保持一致的状态。这意味着事务的操作不会破坏数据库的完整性约束，如外键、唯一性约束等。

**隔离性（Isolation）：** 多个事务可以并发执行，每个事务似乎都是在独立的环境中执行，互不干扰。事务的隔离性防止了并发执行时的数据不一致问题。不同的隔离级别提供了不同程度的隔离，例如读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。

**持久性（Durability）：** 一旦事务成功提交，其结果应该是永久性的，即使系统崩溃或发生其他故障，数据库也应该能够恢复到事务提交后的状态。持久性确保了数据的可靠性。



### 索引的概念、原理，索引的本质是什么

MySQL索引是一种数据结构，用于提高数据库查询的速度和效率。它类似于书中的目录，可以帮助数据库系统快速定位到存储数据的位置，减少了数据库的扫描和比较操作。

**数据结构和原理**

-   **B+Tree索引:** 大部分MySQL存储引擎的默认索引类型。B+Tree是一种平衡多路查找树，可以保证数据的有序性，并且有较高的查找效率。比如 InnoDB存储引擎就采用的B+Tree索引。在B+Tree索引中，索引项是按照顺序排列并分布在树上的，这样对范围查询和排序就有了很大的优势。

-   **Hash索引: ** Memory存储引擎的索引就采用了Hash索引，适用于等值查询，但不支持范围查询和排序等操作。Hash索引的查询速度非常快，但是索引的维护成本较高，而且Hash冲突的存在也会影响查询性能。
    需要注意的是，还有其他类型的索引，例如空间数据索引(基于R-Tree的GIS空间索引)，全文索引等，但是在底层使用最广泛的数据结构依然是B+Tree索引和Hash索引。

**索引分类**

-   主键索引(Primary Key): 主键索引是所有InnoDB表必须的，且一个表中只能有一个主键索引。InnoDB的数据文件就是按照主键顺序存放的，也就是聚簇索引。主键索引的选择对查询的性能有很大的影响。
-   唯一索引(Unique Index): 唯一索引中的键值必须唯一，但允许有空值。如果是组合索引，则组合的值必须唯一。
-   普通索引(Normal Index)或非唯一索引:这是最基本的索引，没有任何约束。
-   全文索引 (Fulltext Index):主要用于全文搜索，即针对大文本进行的搜索。MySQL的InnoDB和 MyISAM存储引擎都支持全文索引。但是，InnoDB的全文索引在功能和性能上与MyISAM存在差距，如需对全文索引的性能要求较高，或者对全文索引的更高级功能有所要求，建议使用MyISAM存储引擎。

**适合索引：**

-   常用作查询条件的字段: 如果表的某个列经常用于where子句中，为该列建立一个索引可以极大地提高查找速度。
-   常用作连接的列: 如果一列经常出现在多表查询的关联条件里，为该列建索引一样可以提高效率。
-   在ORDER BY, GROUP BY或DISTINCT中经常使用的列:这能大大提升排序和分组等操作的速度。
-   区分度比较高的字段:比如每个用户会有一个ID,显然每个用户的ID都是不一样的，这样的话，数据的区分度就很高，就适合做索引，但是想用户性别这种，只有男，女两种，基本没有啥区分度，那么不适合做索引。

**不适合索引：**

-   数据重复度高的字段: 字段的唯一性越好，索引性能越好。如果字段中数据重复度高，那么这个字段就不适合创建索引。比如:性别，只有男、女两个值，在几千万、几亿的数据表中，这个字段的重复度就非常高。

-   数据量小或者数据分布极为不均匀的字段: 如果表的记录非常少，或者表中的数据分布非常不均，索引将无法发挥效用。

-   经常改动的字段: 如果某列经常进行insert、delete、update操作，对这样的列建立索引，虽然可以提高查询速度，但同时也会降低更新速度。

-   不常用于查询条件的字段: 如果某个字段不常用于查询条件(WHERE子句中)，那么创建索引不但无法提升性能，反而会浪费磁盘空间。

    

### SQL中where和having的区别

在 SQL 中，`WHERE` 和 `HAVING` 子句都用于过滤数据，但它们应用的时机和作用域略有不同。

`WHERE` 子句：

-   **作用：** `WHERE` 子句用于在检索数据时对行进行条件过滤。它通常出现在 `SELECT`、`UPDATE`、`DELETE` 等语句中。
-   **作用范围：** `WHERE` 子句作用于行级别的数据过滤，即在数据从表中选择出来之前应用条件。
-   **使用场景：** 适用于对行的过滤，常用于基本的条件筛选，比如等于、大于、小于等条件。

```sql
SELECT column1, column2
FROM table_name
WHERE condition;
```

`HAVING` 子句：

-   **作用：** `HAVING` 子句用于在对聚合函数的结果进行过滤。它通常出现在 `SELECT` 语句中，与 `GROUP BY` 一同使用。
-   **作用范围：** `HAVING` 子句作用于分组级别的数据过滤，即在对聚合函数应用后，对聚合结果进行条件过滤。
-   使用场景：** 适用于对聚合结果进行条件筛选，常用于与 `GROUP BY` 一同使用，筛选分组的汇总结果。

```sql
SELECT column1, COUNT(*)
FROM table_name
GROUP BY column1
HAVING COUNT(*) > 1;
```



### MySQL检索效率

-   const > ref > ref_or_null > range > index > all



### 关系型数据库和非关系型数据库

关系型数据库（RDBMS）和非关系型数据库（NoSQL）是两种不同类型的数据库系统，它们在数据存储和检索的方式上有很大的区别。

**关系型数据库（RDBMS）：**

-   **数据结构：** 数据以表格（二维表）的形式存储，表格包含行和列，行表示记录，列表示字段。

-   **模式：** 数据需要按照预定义的模式（表结构）存储，通常使用 SQL（Structured Query Language）进行定义和查询。
-   **事务：** 支持事务处理，具有 ACID 属性（原子性、一致性、隔离性、持久性）。
-   **扩展性：** 垂直扩展（增加服务器性能）是常见的方式，但相对来说相对较昂贵。
-   **适用场景：** 适用于需要强一致性和复杂查询的应用，如金融系统、企业资源规划（ERP）系统等。
-   **例子：** MySQL、PostgreSQL、Oracle Database、SQL Server等。

**非关系型数据库（NoSQL）：**

-   **数据结构：** 可以使用多种数据模型，包括文档型、键值对、列族型、图型等，数据通常以 JSON 或 BSON 格式存储。
-   **模式：** 无需事先定义模式，灵活适应不同类型和结构的数据。
-   **事务：** 可以是非 ACID 的，具体取决于数据库的类型和配置。一些 NoSQL 数据库强调性能和可用性而不是强一致性。
-   **扩展性：** 水平扩展性（通过增加节点或服务器来处理更多负载）是比较容易实现的。
-   **适用场景：** 适用于需要处理大量数据、需要高度可扩展性和灵活性的应用，如社交媒体、大数据分析等。
-   **例子：** MongoDB、Cassandra、Redis、Couchbase等。

选择关系型数据库还是非关系型数据库通常取决于应用的具体需求，例如数据结构、一致性要求、查询复杂性以及对水平扩展的需求。在某些情况下，两者也可以结合使用，这被称为多模型数据库。



### 外键

外键(Foreign Key) 是用于建立表与表之间关联关系的一种约束。它定义了两个表之间的引用关系，确保了数据的完整性和一致性。

外键通常由一个表中的字段(子表)引用另一个表中的主键字段(父表)。子表中的外键列包含了父表中对应主键列的值，从而建立了两个表之间的关联。

外键的作用有以下几个方面:

-   数据完整性: 外键约束保证了数据的完整性，防止了子表中引用了不存在的父表数据。如果试图在子表中插入一个不符合外键约束的值，将会被拒绝。

-   数据一致性: 外键约束确保了表之间的数据一致性。当父表中的主键值更新或删除时，相关联的子表中的外键值也会相应更新或删除，保持了数据的一致性。

-   查询优化: 外键可以用于优化查询操作。通过外键关联，可以轻松地进行表之间的关联查询，提高查询效率。